/*
 * Copyright The Dragonfly Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dfgettask

import (
	"context"
	"fmt"
	"github.com/dragonflyoss/Dragonfly/pkg/metricsutils"
	"github.com/dragonflyoss/Dragonfly/supernode/config"

	"github.com/dragonflyoss/Dragonfly/apis/types"
	"github.com/dragonflyoss/Dragonfly/pkg/errortypes"
	"github.com/dragonflyoss/Dragonfly/pkg/stringutils"
	"github.com/dragonflyoss/Dragonfly/pkg/syncmap"
	"github.com/dragonflyoss/Dragonfly/supernode/daemon/mgr"
	dutil "github.com/dragonflyoss/Dragonfly/supernode/daemon/util"

	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
)

var _ mgr.DfgetTaskMgr = &Manager{}

type metrics struct {
	dfgetTasks       *prometheus.GaugeVec
	dfgetTasksDaemon *prometheus.GaugeVec
}

func newMetrics() *metrics {
	return &metrics{
		dfgetTasks: metricsutils.NewGauge(config.SubsystemSupernode, "dfgettasks",
			"The number of dfget tasks", []string{"taskid", "callsystem"}),

		dfgetTasksDaemon: metricsutils.NewGauge(config.SubsystemSupernode, "daemon_dfgettasks",
			"The number of dfget tasks from dfdaemon", []string{"taskid", "callsystem"}),
	}
}

// Manager is an implementation of the interface of DfgetTaskMgr.
type Manager struct {
	dfgetTaskStore *dutil.Store
	ptoc           *syncmap.SyncMap
	metrics        *metrics
}

// NewManager returns a new Manager.
func NewManager() (*Manager, error) {
	return &Manager{
		dfgetTaskStore: dutil.NewStore(),
		ptoc:           syncmap.NewSyncMap(),
		metrics:        newMetrics(),
	}, nil
}

// Add a new dfgetTask, we use clientID and taskID to identify a dfgetTask uniquely.
// ClientID should be generated by dfget, supernode will use it directly.
// NOTE: We should create a new dfgetTask for each download process,
//       even if the downloads initiated by the same machine.
func (dtm *Manager) Add(ctx context.Context, dfgetTask *types.DfGetTask) error {
	if stringutils.IsEmptyStr(dfgetTask.Path) {
		return errors.Wrapf(errortypes.ErrEmptyValue, "Path")
	}

	if stringutils.IsEmptyStr(dfgetTask.PeerID) {
		return errors.Wrapf(errortypes.ErrEmptyValue, "PeerID")
	}

	key, err := generateKey(dfgetTask.CID, dfgetTask.TaskID)
	if err != nil {
		return err
	}

	// the default status of DfgetTask is WAITING
	if stringutils.IsEmptyStr(dfgetTask.Status) {
		dfgetTask.Status = types.DfGetTaskStatusWAITING
	}

	// TODO: should we verify that the peerID is valid here.

	dtm.ptoc.Add(generatePeerKey(dfgetTask.PeerID, dfgetTask.TaskID), dfgetTask.CID)
	dtm.dfgetTaskStore.Put(key, dfgetTask)

	if dfgetTask.Dfdaemon {
		dtm.metrics.dfgetTasksDaemon.WithLabelValues(dfgetTask.TaskID, dfgetTask.CallSystem).Inc()
	} else {
		dtm.metrics.dfgetTasks.WithLabelValues(dfgetTask.TaskID, dfgetTask.CallSystem).Inc()
	}

	return nil
}

// Get a dfgetTask info with specified clientID and taskID.
func (dtm *Manager) Get(ctx context.Context, clientID, taskID string) (dfgetTask *types.DfGetTask, err error) {
	return dtm.getDfgetTask(clientID, taskID)
}

// GetCIDByPeerIDAndTaskID returns cid with specified peerID and taskID.
func (dtm *Manager) GetCIDByPeerIDAndTaskID(ctx context.Context, peerID, taskID string) (string, error) {
	return dtm.ptoc.GetAsString(generatePeerKey(peerID, taskID))
}

// List returns the list of dfgetTask.
func (dtm *Manager) List(ctx context.Context, filter map[string]string) (dfgetTaskList []*types.DfGetTask, err error) {
	return nil, nil
}

// Delete a dfgetTask with clientID and taskID.
func (dtm *Manager) Delete(ctx context.Context, clientID, taskID string) error {
	key, err := generateKey(clientID, taskID)
	if err != nil {
		return err
	}

	dfgetTask, err := dtm.getDfgetTask(clientID, taskID)
	if err != nil {
		return err
	}
	dtm.ptoc.Delete(generatePeerKey(dfgetTask.PeerID, dfgetTask.TaskID))
	if dfgetTask.Dfdaemon {
		dtm.metrics.dfgetTasksDaemon.WithLabelValues(dfgetTask.TaskID, dfgetTask.CallSystem).Dec()
	} else {
		dtm.metrics.dfgetTasks.WithLabelValues(dfgetTask.TaskID, dfgetTask.CallSystem).Dec()
	}
	return dtm.dfgetTaskStore.Delete(key)
}

// UpdateStatus update the status of dfgetTask with specified clientID and taskID.
func (dtm *Manager) UpdateStatus(ctx context.Context, clientID, taskID, status string) error {
	dfgetTask, err := dtm.getDfgetTask(clientID, taskID)
	if err != nil {
		return err
	}

	if dfgetTask.Status != types.DfGetTaskStatusSUCCESS {
		dfgetTask.Status = status
	}

	return nil
}

// getDfgetTask gets a DfGetTask from dfgetTaskStore with specified clientID and taskID.
func (dtm *Manager) getDfgetTask(clientID, taskID string) (*types.DfGetTask, error) {
	key, err := generateKey(clientID, taskID)
	if err != nil {
		return nil, err
	}

	v, err := dtm.dfgetTaskStore.Get(key)
	if err != nil {
		return nil, err
	}

	if dfgetTask, ok := v.(*types.DfGetTask); ok {
		return dfgetTask, nil
	}
	return nil, errors.Wrapf(errortypes.ErrConvertFailed, "clientID: %s, taskID: %s: %v", clientID, taskID, v)
}

// generateKey generates a key for a dfgetTask.
func generateKey(cID, taskID string) (string, error) {
	if stringutils.IsEmptyStr(cID) {
		return "", errors.Wrapf(errortypes.ErrEmptyValue, "cID")
	}

	if stringutils.IsEmptyStr(taskID) {
		return "", errors.Wrapf(errortypes.ErrEmptyValue, "taskID")
	}

	return fmt.Sprintf("%s%s%s", cID, "@", taskID), nil
}

func generatePeerKey(peerID, taskID string) string {
	return fmt.Sprintf("%s@%s", peerID, taskID)
}
